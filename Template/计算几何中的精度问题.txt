const double eps=1e-8;
inline int sgn(double a){return a < -eps ? -1 : a < eps ? 0 : 1;}
//a == b   sgn(a - b) == 0
//a != b   sgn(a - b) != 0
//a < b    sgn(a - b) <  0
//a <= b   sgn(a - b) <= 0
//a > b    sgn(a - b) >  0
//a >= b   sgn(a - b) >= 0

x1*x2*x3*...*xn转化成log，然后比较大小的时候一定要用sgn函数啊！！！！！


//3. eps带来的函数越界
//如果sqrt(a), asin(a), acos(a) 中的a是你自己算出来并传进来的，那就得小心了。
//如果a本来应该是0的，由于浮点误差，可能实际是一个绝对值很小的负数(比如1e-12),这样sqrt(a)应得0的，直接因a不在定义域而出错。
//类似地，如果a本来应该是±1,则asin(a)、acos(a)也有可能出错。
//因此，对于此种函数，必需事先对a进行校正。


 //(int)a;  //将a靠进0取整 (int)-2.2 = -2


//现在考虑一种情况,题目要求输出保留两位小数。有个case的正确答案的精确值是0.005,按理应该输出0.01,
//但你的结果可能是0.005000000001(恭喜)，也有可能是0.004999999999(悲剧),
//如果按照printf(“%.2lf”, a)输出，那你的遭遇将和括号里的字相同。
//解决办法是，如果a为正，则输出a+eps, 否则输出a-eps


//ceil(a); floor(a); //顾名思义，向上取证、向下取整。需要注意的是，这两个函数都返回double，而非int

//ICPC题目输出有个不成文的规定(有时也成文)，不要输出: -0.000
//那我们首先要弄清，什么时候按printf(“%.3lf\n”, a)输出会出现这个结果。
//直接给出结果好了：a∈(-0.000499999……, -0.000……1)
//所以，如果你发现a落在这个范围内，请直接输出0.000。更保险的做法是用sprintf直接判断输出结果是不是-0.000再予处理。


//关于set<T>
//有时候我们可能会有这种需求，对浮点数进行 插入、查询是否插入过 的操作。手写hash表是一个方法(hash函数一样要小心设计)，
//但set不是更方便吗。但set好像是按==来判重的呀？貌似行不通呢。经观察,set不是通过==来判断相等的，是通过<来进行的，具体说来
//只要a<b 和 b<a 都不成立，就认为a和b相等，可以发现，
//如果将小于定义成:  bool operator < (const Dat dat)const{return val < dat.val - eps;}就可以解决问题了
//		   (基本类型不能重载运算符，所以封装了下)