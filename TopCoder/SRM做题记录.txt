srm538 ak. 题解在百度空间。
srm537 
	div2 1000pt. 概率题，看清题目，发现是一个树的形状，树根出线的概率是1.0,第2层出线的概率是1.0/2,第三层出线的概率是1.0/2/3,一次类推，加起来就是答案

srm535 ak.
	div1 1000pt. 统计问题。用到了一个多层for循环优化的原理。类似这样for(a) for(b) for(c) for(d)四层嵌套，但是ab和cd之间是无关的，所以可以先算出for(a)for(b)，for(c)for(d), 然后算for(a+b)for(c+d)，这样复杂度就降下来了。
	div1 500pt. 类似分数规划那种的二分答案题，比赛时没往这个方向想。。思想就是，最优化问题，设想最优解，我们会取得一个最优解opt，然后其他的解都大于等于opt，然后大于opt的，小于opt的代入式子看等式会变什么，根据大小关系来二分。
	div2 1000pt. 思路较简单，实现方法很关键。具体如下：
/*
srm 535 div2 1000pt
prob: 给定一种排序规则，两个整数a，b，第一关键字是各位数字和，第二关键字是字典序，然后从小到大排序，sort(0, 10^18, cmp), 然后求数列的第idx项，base1
solu: 大体思路就是先找出第idx项的各位数字和是多少，然后在这个里面计算第idx项。想法很简单，但是实现起来却不是很容易，细节很多，很容易错。
稍微分析之后发现，字符串首位是不是0很容易混淆，既然这样，那就每次都枚举数字的首位，这样就能避免首位为0的情况！然后一个dp数组就可以只管长度和总和了！

这题主要难点在实现上，好的实现方法几乎不用调试，差的实现方法可能几个小时都调不出样例！！ 记住这个枚举首位的思路！！！
*/

srm534   ak.
	div2 1000pt. 卡时限。总状态数目是28^5，共1000多万，需要压缩成int，map<vector<int>, int>这样要挂。
	div1 500pt. 一个observation，最小的15个质数乘积就已经大于10^18了。（需要打表才能发现具体几个，但是需要有这个概念）
	div1 1000pt. prob：类似字符串编辑距离，这里能用的操作是1，交换相邻两个字符。2，把一个字符变成另一个字符。求把字符串S变成T需要的步数。字符串长度2500，只含有26个小写字母。
			solu：几个observation：1）一段字符串变成另一个最多操作s.length()次。2）交换的区间会交叉，但是交叉区域最多一个字符！！。然后dp吧，dp[2500][26],转移2500，总复杂度O(2500*2500*26),Petr貌似复杂度2500^2的。。。




srm533
	div2 1000pt. 期望dp题. dp[i][j]表示当前局面是(i, j)时的最佳期望结果. 计算的时候就是枚举局面(i, j)的x个可选路子, 对于每个路子计算出结果(根据概率加权), 然后x个路子结果取最佳!
	div1 500pt. prob: 给定一个字符矩阵（包含'.'和'#')，走折线，每次走一个'#'走到另一个'#',水平走和竖直走交替，一开始选择一个'#'水平走，问是否能够走完全部的'#',并且每个'#'只经过一次。
			solu：模型转换。观察题目的走法，要经过所有的'#'仅一次。这个很像欧拉路径问题，而欧拉路径的判定是好做的，考虑往这个方向转化。一个'#'相当于要转一次弯，如果我们把水平方向和竖直方向分开，那么走法相当于在两边跳，然后我们构造一个二分图，R*C的，判断欧拉路径。。。
	div1 1000pt. prob: 类似huffman编码，但是有三条分叉，权值分别是(2,2,3). 给定<=30个单词的出现频率(<=1000),给他们编码，要求的是最短的编码长度和达到这个长度编码方式数目。
			solu: 不等权的huffman编码问题是np的,但是这题数据只有30,可以考虑dp..自己没想出来,说下editorial里面的思路, 普通的huffman编码是利用贪心从树的底层往树根方向考虑,而这题是三叉树,而且权值不定,编码树的底层形态完全不明朗!所以我们尝试从上往下考虑, 由于是无前缀编码,所以一个节点要是被用来编码了,那么它儿子都不能了.而一个节点的直系子节点最多往下3层,所以从上往下考虑的话,一棵树的状态只需要记录当前层数的后三层!!! 然后就可以dp了, 把单词频率从大到小排序,然后从树根向树枝dp, 这样可以用n^4的状态和n的转移,总复杂度n^5, 可以pass. 还没实现...

srm531 ak.
	div1 500pt. 思路, 技巧. prob: 给定一个有向图(50个点), 现给节点0一个能量, 每一次一个节点可以消耗一个能量, 然后使得它的后继增加一个能量. 问无限这样下去最终的总能量是多少, 如果是无穷则输出-1.
		solu1: 直接模拟几千会合看最后是否趋于稳定. 这个要使用大数,或者对多个大素数取模(如果这几个素数积大于最大可能的值则能保证完全正确).
		solu2: 图论方法. 首先得出结论, 当且仅当某个点从0点可达, 且在某个圈里, 且出度大于1, 才会导致无穷, 否则有限. 判断是否在某个环内可以使用floyd-warshall算法.
	div1 1000pt. 思维, 实现. prob: 给出一行n(<=50)堆砖块, 每堆砖有height[i]块, 竖直的. 然后要求将其中的第A和B两堆砖搬到其他堆中, 砖上下一个单位长度需要能量1, 从一堆到隔壁堆需要cost能量.问搞定需要的最少能量.
		首先如果只搬一堆, 那么好解决的, 可以二分那个啥...然后需要几个observation: 设A<B, 那么A搬到的地方和B搬到的地方不会交叉, 即A搬到x, 曾B不会搬到小于x的堆中. 那么就只有两种情况, 1: A搬到1~i, B搬到i+1~n. 2: A搬到1~i-1, B搬到i+1~n, 而i既有A又有B. 情况1很好搞. 情况2又需要一个更深的observation: 如果共享的那堆增加x块砖, 那么其他的堆需要增加的块数是又下限的!!!这个限制可以用于二分求出共享堆增加的高度!!!然后...


srm530 div1 AK.
	div1 500pt. 有向图s->t的路径个数, 每一条新加的路都要有之前没有的决策.类似平面图F=E-V+2这个公式的推到思想... tricky!
	div1 1000pt. 先想出一些结论, 然后对数据排序后dp. 最终的dp问题是给定n个数a[],0<=a[i]<=50. 问有多少个这n个数的permutation b[], 满足sigma(a[i]-b[i] )=moves,其中a[i]>=b[i]. 很难想的dp状态, dp[50][50][2500],表示搞到第i位, 前面有j个位置空的, 前面的和为k.这个是没有后效性的, 因为只考虑前i个数的位置情况, 前面的空位需要后面的数来填上.
srm529 div1 AK.
srm528 AK.
srm526.5:  div1 500pt not clear
srm527 AK.
srm526 AK.
srm525 AK.
srm524 AK.
srm523 AK.
srm522 AK.
srm521 AK.
srm520 AK.
srm519 AK.
srm518 
	div1 1000pt 很难想的变换方法... L*logL*logK倒是还算好像...
srm517 AK. 
	div1 900pt trick 1,每行每列只刷一次. 2,肯定有一行或一列没有刷!!!
srm516 AK.
	div2 1000pt 字典序最小的拓扑排序, 很暴力的别样思路.  
	div1 1000pt 欧拉回路(每条边经过一次)存在的两个条件. 1, 每个节点度数为偶数. 2,度数大于0的节点在一个连通分量里面.
			如果再要求回路中相邻边的颜色不同, 那么只要每个节点的临边中最多颜色数<=half就好了.
		这题要计算的不是完美的情况,通过添加一些条件让它变完美情况. 此题解决方案是类似暴力计算2-sat的算法, 我们知道怎么判断一个情况是否有解, 所以我们可以枚举走的方案, 然后找到一个可行的就往后搜就好了, 由于已经判断有解了, 所以不需要回溯!!!(很重要的trick!!)

srm515 div1 AK. div2 1000pt是d1 500的简化版.
	div1 500pt 蛋疼的概率题. 很难想决策, 但是可以dp. 在dp的过程中要update概率, 因为一些事情的发生与否会影响后面相同事件的概率.
	div1 1000pt 一个50*50的map, 里面有20个R, 20个F, 2000个L, 问题是求sigma( for(R)for(F)for(L) RFL在一点会合需要的最小值距离和 )统计问题的优化, 算一个复杂度O(x), 优化到算n的复杂度也是O(x), 类似这样. 使用了一个很好的建图论模型bfs的方法.

srm514 AK.
	div1 250pt. 可达性问题, 需要想法. 你当前在坐标(0, 0), 给定一个int[] x, x[i]表示你可以走8个方向(1,x[i]), (x[i],1), (-1,x[i])...问能不能走到(x, y)
		solu: 比较容易发现可以应用两次x[i], 使得当前从(0, 0)到达(0, 2).这样的话(1, x[i])可以用(1, x[i]%2)来代替!!! 然后清楚了....

	div1 1000pt. 一般.
srm513 ak.
	div1 1000pt. x轴上从0走到X需要最少需要多少步, 中间可以借助镜面反射, 20个镜子,每个镜子最多使用一次. 
		solu: 可以发现, 只要不是镜面反射走的那些路都可以移到一开始走!!! 然后在x处经过镜面y反射后的位置z=2*y-x, ...然后迭代之后发现是一堆正的减去一堆负的...O(20*2^20) 或者O(20*20*3^10)的算法.

srm512 ak.
	div1 500pt. 给定一个数列, 计算属于类fib数列的最长的子序列. trick:具有递推式f[i]=f[i-2]+f[i-1]的数列, 知道数列中的两个数A,B和他们中间隔了几个数D, 可以推出A后面那个数...因为是A, x, A+x, A+2x,...,B, 所以...
	div1 1000pt. 排列组合计数问题.给定一个int[] a, 其中(1<=a[i]<=10^9). 问你存在多少个正序列int[] b, 使得对于每一个a[i]都有一个之前没用过的b[j]<=a[i].
		solu1: 可以发现a的顺序是无关的, 可以先sort(a).然后一次枚举[1,a[0]], [a[0]+1, a[1]], [a[1]+1, a[2]],...分别选择了几个, n^3的dp.
		solu2: 同sort(a). 然后计算的时候采用总情况数减去不合法数目的方法. n^2的算法.
		ps: 排列组合问题特别需要从多个角度思考, 千万不能在一棵树上吊死. 要多多尝试其他的思路.

srm511 ak.
	div1 500pt. 博弈题.给定一个int[] a和一个memory x. x初始值为0.然后两个人开始game, 每一回合中一个人从a选择一个数从中删除, 并x|=a[i].当a为空或者某人搞完之后x=511时输. 状态记录方式比较赞. dp[512][50]...
	div1 1000pt. 蛋疼题, 想出一些observation之后, 算法比较难实现.关键一点是当init中存在两个相邻的字符相同时(同为'0'或同为'1'), init的环状就可以化为链状, 可以dp了... 我的策略是枚举,遇到一个'?'就枚举两种情况, 递归下去, 如果出现连续两个'0'或'1', 那么调用subDP并返回! 这样复杂度是O(50^4)...
	
srm510 ak.
	div1 500pt.  枚举的策略. 给定一个区间[a, b], Jane先在[a, b], 范围10^10选择一个长度为jLen的区间, 然后Brus在Jane的区间里面再选择一个bLen长度的区间, 这样一次的结果res是Brus所选区间里面lucky number的个数(4,7,..), Jane的策略是使res尽量大, Brus的策略是使res尽量小. 问这样的话, res是多少.
		solu: 如果a,b的范围够小的话, 我们可以直接枚举Jane和Brus选择的区间, 这样取一下opt就可以了. 但是范围大了的话我们必须尽量减少枚举的量, 实际上这是可行的, 因为对于两个人来说, 选择区间的起点的好坏程度都有有一个单调性, 这样就存在了选x比选x+1为起点更好等类似的结论. 根据这个我们可以只枚举x, 而不用再枚举x+1...

	div1 1000pt. 分类讨论的典型应用. 给定一个n(10^16内), 问存在多少个进制(base)使得n在base进制的表示下每一位数字都是lucky number.(lucky number不光是4,7, 还可以是44, 47, 444,...).
		solu: 假设n在x进制下每一位都是lucky number. 那么n可以表示为n=a, n=a*x+b, n=a*x^2+b*x+c, n=a*x^3+b*x^2+c*x+d, ...由于n的大小的限制, 当x的阶数变大的时候, x的可能值迅速变小!! 比如x^3, 这时x的最大值3次根号n, 对于n=10^16来说, 这个数字不到10^6, 所以对于x的阶数>=3的, 我们可以直接枚举x. 现在剩下的就是阶数是0, 1, 2的情况, 通过分析, 这些情况, 可以通过枚举a,b,c等参数来解决!!


srm483 ak.
	div1 500pt. 非常好的dp题. 状态很难想!. prob: 给定两个int[] val, minus, 其中minus[i]<=500. 规定选择了第i个之后val[j]会减去 minus[i]/2^(abs(i-j)). 每个东西最多被选择一次. 问至少选择几个使得val数组全部<=0, 如果没有方案则输出-1.
	solu: 可以发现minus[i]<=500, 这样的话就算选择了它, 它对其它东西的影响最多也是相邻的8个.这样我们只需要记录当前位置cur之前的8个(包括cur)的状态就可以进行dp求解了. 但是这个状态很难记录, 因为val[cur-0~7]可能被前面的搞过了, 再进一步, 我们记录下cur之前16个选择情况就可以确定cur-0~7的val值了!!! 这样可以定义dp[50][1<<16], dp[i][j]表示当前位置是i, i-0~15的选择状况是j, 且i-8之前的val都<=0了的最少选择数目....
	
	div1 900pt. 想法, 很容易想到二分的错误算法. 事实上答案可能的区间很小, 在2000的范围内, 所以可以暴力找!! 但是check的算法很容易写成n^2的, 这样会tle, 用二分查找可以优化到nlogn.

srm429 ak.
	div1 1000pt. 解决方案和srm516 div1 1000pt差不多, 也是要求一个字典序最小的ans. 思路就是我们知道怎么判断剩下的局面是否有解, 所以我们在当前决策的时候可以一次从字典序小的地方开始枚举, 直到结束或者中途就判断无解...此题的check函数很好想, 比srm516那题简单多了.


srm422 ak.
	div1 1000pt. 匹配问题. 一个二分图, 左边W类点, 右边G, S类点. (Wi, Gj, Sk)结合在一起算1分, 其中Wi-Gj, Wi-Sk有边相连. 求最大得分.
		solu: 当右边只有一类点时, 这是一个二分图最大匹配问题. 可以用匈牙利算法或者最大流解决. 这题里面就只能最大流解决, 设一个圆点source->G类点, S类点->sink, W类点分点, 流量全部为1. 最大流即可!.



srm346.
	div1 500pt, 字典序最小问题。greedy+check。
	div1 1000pt，圆并的周长，因为只有50个，所以直接暴力枚举。


